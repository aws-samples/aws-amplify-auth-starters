{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Constants from 'expo-constants';\nimport qs from 'qs';\nimport URL from 'url-parse';\nimport Linking from \"./LinkingModule\";\nvar manifest = Constants.manifest;\n\nfunction _usesCustomScheme() {\n  return Constants.appOwnership === 'standalone' && manifest.scheme;\n}\n\nfunction _getHostUri() {\n  if (!manifest.hostUri && !_usesCustomScheme()) {\n    return _removeScheme(Constants.linkingUri).replace(/\\/--($|\\/.*$)/, '');\n  }\n\n  return manifest.hostUri;\n}\n\nfunction _isExpoHosted() {\n  var hostUri = _getHostUri();\n\n  return !!(hostUri && (/^(.*\\.)?(expo\\.io|exp\\.host|exp\\.direct|expo\\.test)(:.*)?(\\/.*)?$/.test(hostUri) || manifest.developer));\n}\n\nfunction _removeScheme(url) {\n  return url.replace(/^[a-zA-Z0-9+.-]+:\\/\\//, '');\n}\n\nfunction _removePort(url) {\n  return url.replace(/(?=([a-zA-Z0-9+.-]+:\\/\\/)?[^/]):\\d+/, '');\n}\n\nfunction _removeLeadingSlash(url) {\n  return url.replace(/^\\//, '');\n}\n\nfunction _removeTrailingSlash(url) {\n  return url.replace(/\\/$/, '');\n}\n\nfunction _removeTrailingSlashAndQueryString(url) {\n  return url.replace(/\\/?\\?.*$/, '');\n}\n\nfunction makeUrl() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var scheme = 'exp';\n  var manifestScheme = manifest.scheme || manifest.detach && manifest.detach.scheme;\n\n  if (Constants.appOwnership === 'standalone' && manifestScheme) {\n    scheme = manifestScheme;\n  } else if (Constants.appOwnership === 'standalone' && !manifestScheme) {\n    throw new Error('Cannot make a deep link into a standalone app with no custom scheme defined');\n  } else if (Constants.appOwnership === 'expo' && !manifestScheme) {\n    console.warn('Linking requires that you provide a `scheme` in app.json for standalone apps - if it is left blank, your app may crash. The scheme does not apply to development in the Expo client but you should add it as soon as you start working with Linking to avoid creating a broken build. Add a `scheme` to silence this warning. Learn more about Linking at https://docs.expo.io/versions/latest/workflow/linking/');\n  }\n\n  var hostUri = _getHostUri() || '';\n\n  if (_usesCustomScheme() && _isExpoHosted()) {\n    hostUri = '';\n  }\n\n  if (path) {\n    if (_isExpoHosted() && hostUri) {\n      path = \"/--/\" + _removeLeadingSlash(path);\n    }\n\n    if (!path.startsWith('/')) {\n      path = \"/\" + path;\n    }\n  } else {\n    path = '';\n  }\n\n  var queryString = '';\n  var queryStringMatchResult = hostUri.match(/(.*)\\?(.+)/);\n\n  if (queryStringMatchResult) {\n    hostUri = queryStringMatchResult[1];\n    queryString = queryStringMatchResult[2];\n    var paramsFromHostUri = {};\n\n    try {\n      var parsedParams = qs.parse(queryString);\n\n      if (typeof parsedParams === 'object') {\n        paramsFromHostUri = parsedParams;\n      }\n    } catch (e) {}\n\n    queryParams = _objectSpread({}, queryParams, {}, paramsFromHostUri);\n  }\n\n  queryString = qs.stringify(queryParams);\n\n  if (queryString) {\n    queryString = \"?\" + queryString;\n  }\n\n  hostUri = _removeTrailingSlash(hostUri);\n  return encodeURI(scheme + \"://\" + hostUri + path + queryString);\n}\n\nfunction parse(url) {\n  if (!url) {\n    throw new Error('parse cannot be called with a null value');\n  }\n\n  var parsed = URL(url, true);\n\n  for (var param in parsed.query) {\n    parsed.query[param] = decodeURIComponent(parsed.query[param]);\n  }\n\n  var queryParams = parsed.query;\n  var hostUri = _getHostUri() || '';\n\n  var hostUriStripped = _removePort(_removeTrailingSlashAndQueryString(hostUri));\n\n  var path = parsed.pathname || null;\n  var hostname = parsed.hostname || null;\n  var scheme = parsed.protocol || null;\n\n  if (scheme) {\n    scheme = scheme.substring(0, scheme.length - 1);\n  }\n\n  if (path) {\n    path = _removeLeadingSlash(path);\n    var expoPrefix = null;\n\n    if (hostUriStripped) {\n      var parts = hostUriStripped.split('/');\n      expoPrefix = parts.slice(1).concat(['--/']).join('/');\n    }\n\n    if (_isExpoHosted() && !_usesCustomScheme() && expoPrefix && path.startsWith(expoPrefix)) {\n      path = path.substring(expoPrefix.length);\n      hostname = null;\n    } else if (path.indexOf('+') > -1) {\n      path = path.substring(path.indexOf('+') + 1);\n    }\n  }\n\n  return {\n    hostname: hostname,\n    path: path,\n    queryParams: queryParams,\n    scheme: scheme\n  };\n}\n\nfunction parseInitialURLAsync() {\n  var initialUrl;\n  return _regeneratorRuntime.async(function parseInitialURLAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(Linking.getInitialURL());\n\n        case 2:\n          initialUrl = _context.sent;\n\n          if (initialUrl) {\n            _context.next = 5;\n            break;\n          }\n\n          return _context.abrupt(\"return\", {\n            scheme: null,\n            hostname: null,\n            path: null,\n            queryParams: null\n          });\n\n        case 5:\n          return _context.abrupt(\"return\", parse(initialUrl));\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar newLinking = new Linking.constructor();\nnewLinking.makeUrl = makeUrl;\nnewLinking.parse = parse;\nnewLinking.parseInitialURLAsync = parseInitialURLAsync;\nexport default newLinking;","map":{"version":3,"sources":["../../src/Linking/Linking.ts"],"names":[],"mappings":";;;;;;;AAAA,OAAO,SAAP,MAAsB,gBAAtB;AACA,OAAO,EAAP,MAAe,IAAf;AAEA,OAAO,GAAP,MAAgB,WAAhB;AAGA,OAAO,OAAP;IAEQ,Q,GAAa,S,CAAb,Q;;AAER,SAAS,iBAAT,GAA0B;AACxB,SAAO,SAAS,CAAC,YAAV,KAA2B,YAA3B,IAA2C,QAAQ,CAAC,MAA3D;AACD;;AAED,SAAS,WAAT,GAAoB;AAClB,MAAI,CAAC,QAAQ,CAAC,OAAV,IAAqB,CAAC,iBAAiB,EAA3C,EAA+C;AAG7C,WAAO,aAAa,CAAC,SAAS,CAAC,UAAX,CAAb,CAAoC,OAApC,CAA4C,eAA5C,EAA6D,EAA7D,CAAP;AACD;;AACD,SAAO,QAAQ,CAAC,OAAhB;AACD;;AAED,SAAS,aAAT,GAAsB;AACpB,MAAM,OAAO,GAAG,WAAW,EAA3B;;AACA,SAAO,CAAC,EACN,OAAO,KACN,oEAAoE,IAApE,CAAyE,OAAzE,KACC,QAAQ,CAAC,SAFJ,CADD,CAAR;AAKD;;AAED,SAAS,aAAT,CAAuB,GAAvB,EAAkC;AAChC,SAAO,GAAG,CAAC,OAAJ,CAAY,uBAAZ,EAAqC,EAArC,CAAP;AACD;;AAED,SAAS,WAAT,CAAqB,GAArB,EAAgC;AAC9B,SAAO,GAAG,CAAC,OAAJ,CAAY,qCAAZ,EAAmD,EAAnD,CAAP;AACD;;AAED,SAAS,mBAAT,CAA6B,GAA7B,EAAwC;AACtC,SAAO,GAAG,CAAC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAP;AACD;;AAED,SAAS,oBAAT,CAA8B,GAA9B,EAAyC;AACvC,SAAO,GAAG,CAAC,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAP;AACD;;AAED,SAAS,kCAAT,CAA4C,GAA5C,EAAuD;AACrD,SAAO,GAAG,CAAC,OAAJ,CAAY,UAAZ,EAAwB,EAAxB,CAAP;AACD;;AAED,SAAS,OAAT,GAAiE;AAAA,MAAhD,IAAgD,uEAAjC,EAAiC;AAAA,MAA7B,WAA6B,uEAAF,EAAE;AAC/D,MAAI,MAAM,GAAG,KAAb;AACA,MAAI,cAAc,GAAG,QAAQ,CAAC,MAAT,IAAoB,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,MAAT,CAAgB,MAA5E;;AAEA,MAAI,SAAS,CAAC,YAAV,KAA2B,YAA3B,IAA2C,cAA/C,EAA+D;AAC7D,IAAA,MAAM,GAAG,cAAT;AACD,GAFD,MAEO,IAAI,SAAS,CAAC,YAAV,KAA2B,YAA3B,IAA2C,CAAC,cAAhD,EAAgE;AACrE,UAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACD,GAFM,MAEA,IAAI,SAAS,CAAC,YAAV,KAA2B,MAA3B,IAAqC,CAAC,cAA1C,EAA0D;AAC/D,IAAA,OAAO,CAAC,IAAR,CACE,kZADF;AAGD;;AAED,MAAI,OAAO,GAAG,WAAW,MAAM,EAA/B;;AACA,MAAI,iBAAiB,MAAM,aAAa,EAAxC,EAA4C;AAC1C,IAAA,OAAO,GAAG,EAAV;AACD;;AAED,MAAI,IAAJ,EAAU;AACR,QAAI,aAAa,MAAM,OAAvB,EAAgC;AAC9B,MAAA,IAAI,YAAU,mBAAmB,CAAC,IAAD,CAAjC;AACD;;AAED,QAAI,CAAC,IAAI,CAAC,UAAL,CAAgB,GAAhB,CAAL,EAA2B;AACzB,MAAA,IAAI,SAAO,IAAX;AACD;AACF,GARD,MAQO;AACL,IAAA,IAAI,GAAG,EAAP;AACD;;AAID,MAAI,WAAW,GAAG,EAAlB;AACA,MAAI,sBAAsB,GAAG,OAAO,CAAC,KAAR,CAAc,YAAd,CAA7B;;AACA,MAAI,sBAAJ,EAA4B;AAC1B,IAAA,OAAO,GAAG,sBAAsB,CAAC,CAAD,CAAhC;AACA,IAAA,WAAW,GAAG,sBAAsB,CAAC,CAAD,CAApC;AACA,QAAI,iBAAiB,GAAG,EAAxB;;AACA,QAAI;AACF,UAAI,YAAY,GAAG,EAAE,CAAC,KAAH,CAAS,WAAT,CAAnB;;AACA,UAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AACpC,QAAA,iBAAiB,GAAG,YAApB;AACD;AACF,KALD,CAKE,OAAO,CAAP,EAAU,CAAE;;AACd,IAAA,WAAW,qBACN,WADM,MAEN,iBAFM,CAAX;AAID;;AACD,EAAA,WAAW,GAAG,EAAE,CAAC,SAAH,CAAa,WAAb,CAAd;;AACA,MAAI,WAAJ,EAAiB;AACf,IAAA,WAAW,SAAO,WAAlB;AACD;;AAED,EAAA,OAAO,GAAG,oBAAoB,CAAC,OAAD,CAA9B;AAEA,SAAO,SAAS,CAAI,MAAJ,WAAgB,OAAhB,GAA0B,IAA1B,GAAiC,WAAjC,CAAhB;AACD;;AAED,SAAS,KAAT,CAAe,GAAf,EAA0B;AACxB,MAAI,CAAC,GAAL,EAAU;AACR,UAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,MAAM,MAAM,GAAG,GAAG,CAAC,GAAD,EAA6B,IAA7B,CAAlB;;AAEA,OAAK,IAAM,KAAX,IAAoB,MAAM,CAAC,KAA3B,EAAkC;AAChC,IAAA,MAAM,CAAC,KAAP,CAAa,KAAb,IAAsB,kBAAkB,CAAC,MAAM,CAAC,KAAP,CAAa,KAAb,CAAD,CAAxC;AACD;;AACD,MAAI,WAAW,GAAG,MAAM,CAAC,KAAzB;AAEA,MAAM,OAAO,GAAG,WAAW,MAAM,EAAjC;;AACA,MAAM,eAAe,GAAG,WAAW,CAAC,kCAAkC,CAAC,OAAD,CAAnC,CAAnC;;AAEA,MAAI,IAAI,GAAG,MAAM,CAAC,QAAP,IAAmB,IAA9B;AACA,MAAI,QAAQ,GAAG,MAAM,CAAC,QAAP,IAAmB,IAAlC;AACA,MAAI,MAAM,GAAG,MAAM,CAAC,QAAP,IAAmB,IAAhC;;AAEA,MAAI,MAAJ,EAAY;AAEV,IAAA,MAAM,GAAG,MAAM,CAAC,SAAP,CAAiB,CAAjB,EAAoB,MAAM,CAAC,MAAP,GAAgB,CAApC,CAAT;AACD;;AAED,MAAI,IAAJ,EAAU;AACR,IAAA,IAAI,GAAG,mBAAmB,CAAC,IAAD,CAA1B;AAEA,QAAI,UAAU,GAAkB,IAAhC;;AACA,QAAI,eAAJ,EAAqB;AACnB,UAAM,KAAK,GAAG,eAAe,CAAC,KAAhB,CAAsB,GAAtB,CAAd;AACA,MAAA,UAAU,GAAG,KAAK,CACf,KADU,CACJ,CADI,EAEV,MAFU,CAEH,CAAC,KAAD,CAFG,EAGV,IAHU,CAGL,GAHK,CAAb;AAID;;AAED,QAAI,aAAa,MAAM,CAAC,iBAAiB,EAArC,IAA2C,UAA3C,IAAyD,IAAI,CAAC,UAAL,CAAgB,UAAhB,CAA7D,EAA0F;AACxF,MAAA,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,UAAU,CAAC,MAA1B,CAAP;AACA,MAAA,QAAQ,GAAG,IAAX;AACD,KAHD,MAGO,IAAI,IAAI,CAAC,OAAL,CAAa,GAAb,IAAoB,CAAC,CAAzB,EAA4B;AACjC,MAAA,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,IAAI,CAAC,OAAL,CAAa,GAAb,IAAoB,CAAnC,CAAP;AACD;AACF;;AAED,SAAO;AACL,IAAA,QAAQ,EAAR,QADK;AAEL,IAAA,IAAI,EAAJ,IAFK;AAGL,IAAA,WAAW,EAAX,WAHK;AAIL,IAAA,MAAM,EAAN;AAJK,GAAP;AAMD;;AAED,SAAe,oBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2CAC2B,OAAO,CAAC,aAAR,EAD3B;;AAAA;AACQ,UAAA,UADR;;AAAA,cAEO,UAFP;AAAA;AAAA;AAAA;;AAAA,2CAGW;AACL,YAAA,MAAM,EAAE,IADH;AAEL,YAAA,QAAQ,EAAE,IAFL;AAGL,YAAA,IAAI,EAAE,IAHD;AAIL,YAAA,WAAW,EAAE;AAJR,WAHX;;AAAA;AAAA,2CAWS,KAAK,CAAC,UAAD,CAXd;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqBA,IAAI,UAAU,GAAG,IAAI,OAAO,CAAC,WAAZ,EAAjB;AAEA,UAAU,CAAC,OAAX,GAAqB,OAArB;AACA,UAAU,CAAC,KAAX,GAAmB,KAAnB;AACA,UAAU,CAAC,oBAAX,GAAkC,oBAAlC;AAEA,eAAe,UAAf","sourcesContent":["import Constants from 'expo-constants';\nimport qs from 'qs';\nimport { LinkingStatic } from 'react-native';\nimport URL from 'url-parse';\n\nimport { ParsedURL, QueryParams } from './Linking.types';\nimport Linking from './LinkingModule';\n\nconst { manifest } = Constants;\n\nfunction _usesCustomScheme(): boolean {\n  return Constants.appOwnership === 'standalone' && manifest.scheme;\n}\n\nfunction _getHostUri(): string {\n  if (!manifest.hostUri && !_usesCustomScheme()) {\n    // we're probably not using up-to-date xdl, so just fake it for now\n    // we have to remove the /--/ on the end since this will be inserted again later\n    return _removeScheme(Constants.linkingUri).replace(/\\/--($|\\/.*$)/, '');\n  }\n  return manifest.hostUri;\n}\n\nfunction _isExpoHosted(): boolean {\n  const hostUri = _getHostUri();\n  return !!(\n    hostUri &&\n    (/^(.*\\.)?(expo\\.io|exp\\.host|exp\\.direct|expo\\.test)(:.*)?(\\/.*)?$/.test(hostUri) ||\n      manifest.developer)\n  );\n}\n\nfunction _removeScheme(url: string) {\n  return url.replace(/^[a-zA-Z0-9+.-]+:\\/\\//, '');\n}\n\nfunction _removePort(url: string) {\n  return url.replace(/(?=([a-zA-Z0-9+.-]+:\\/\\/)?[^/]):\\d+/, '');\n}\n\nfunction _removeLeadingSlash(url: string) {\n  return url.replace(/^\\//, '');\n}\n\nfunction _removeTrailingSlash(url: string) {\n  return url.replace(/\\/$/, '');\n}\n\nfunction _removeTrailingSlashAndQueryString(url: string) {\n  return url.replace(/\\/?\\?.*$/, '');\n}\n\nfunction makeUrl(path: string = '', queryParams: QueryParams = {}): string {\n  let scheme = 'exp';\n  let manifestScheme = manifest.scheme || (manifest.detach && manifest.detach.scheme);\n\n  if (Constants.appOwnership === 'standalone' && manifestScheme) {\n    scheme = manifestScheme;\n  } else if (Constants.appOwnership === 'standalone' && !manifestScheme) {\n    throw new Error('Cannot make a deep link into a standalone app with no custom scheme defined');\n  } else if (Constants.appOwnership === 'expo' && !manifestScheme) {\n    console.warn(\n      'Linking requires that you provide a `scheme` in app.json for standalone apps - if it is left blank, your app may crash. The scheme does not apply to development in the Expo client but you should add it as soon as you start working with Linking to avoid creating a broken build. Add a `scheme` to silence this warning. Learn more about Linking at https://docs.expo.io/versions/latest/workflow/linking/'\n    );\n  }\n\n  let hostUri = _getHostUri() || '';\n  if (_usesCustomScheme() && _isExpoHosted()) {\n    hostUri = '';\n  }\n\n  if (path) {\n    if (_isExpoHosted() && hostUri) {\n      path = `/--/${_removeLeadingSlash(path)}`;\n    }\n\n    if (!path.startsWith('/')) {\n      path = `/${path}`;\n    }\n  } else {\n    path = '';\n  }\n\n  // merge user-provided query params with any that were already in the hostUri\n  // e.g. release-channel\n  let queryString = '';\n  let queryStringMatchResult = hostUri.match(/(.*)\\?(.+)/);\n  if (queryStringMatchResult) {\n    hostUri = queryStringMatchResult[1];\n    queryString = queryStringMatchResult[2];\n    let paramsFromHostUri = {};\n    try {\n      let parsedParams = qs.parse(queryString);\n      if (typeof parsedParams === 'object') {\n        paramsFromHostUri = parsedParams;\n      }\n    } catch (e) {}\n    queryParams = {\n      ...queryParams,\n      ...paramsFromHostUri,\n    };\n  }\n  queryString = qs.stringify(queryParams);\n  if (queryString) {\n    queryString = `?${queryString}`;\n  }\n\n  hostUri = _removeTrailingSlash(hostUri);\n\n  return encodeURI(`${scheme}://${hostUri}${path}${queryString}`);\n}\n\nfunction parse(url: string): ParsedURL {\n  if (!url) {\n    throw new Error('parse cannot be called with a null value');\n  }\n\n  const parsed = URL(url, /* parseQueryString */ true);\n\n  for (const param in parsed.query) {\n    parsed.query[param] = decodeURIComponent(parsed.query[param]!);\n  }\n  let queryParams = parsed.query;\n\n  const hostUri = _getHostUri() || '';\n  const hostUriStripped = _removePort(_removeTrailingSlashAndQueryString(hostUri));\n\n  let path = parsed.pathname || null;\n  let hostname = parsed.hostname || null;\n  let scheme = parsed.protocol || null;\n\n  if (scheme) {\n    // Remove colon at end\n    scheme = scheme.substring(0, scheme.length - 1);\n  }\n\n  if (path) {\n    path = _removeLeadingSlash(path);\n\n    let expoPrefix: string | null = null;\n    if (hostUriStripped) {\n      const parts = hostUriStripped.split('/');\n      expoPrefix = parts\n        .slice(1)\n        .concat(['--/'])\n        .join('/');\n    }\n\n    if (_isExpoHosted() && !_usesCustomScheme() && expoPrefix && path.startsWith(expoPrefix)) {\n      path = path.substring(expoPrefix.length);\n      hostname = null;\n    } else if (path.indexOf('+') > -1) {\n      path = path.substring(path.indexOf('+') + 1);\n    }\n  }\n\n  return {\n    hostname,\n    path,\n    queryParams,\n    scheme,\n  };\n}\n\nasync function parseInitialURLAsync(): Promise<ParsedURL> {\n  const initialUrl = await Linking.getInitialURL();\n  if (!initialUrl) {\n    return {\n      scheme: null,\n      hostname: null,\n      path: null,\n      queryParams: null,\n    };\n  }\n\n  return parse(initialUrl);\n}\n\ninterface ExpoLinking extends LinkingStatic {\n  makeUrl: typeof makeUrl;\n  parse: typeof parse;\n  parseInitialURLAsync: typeof parseInitialURLAsync;\n}\n\n// @ts-ignore fix this...\nlet newLinking = new Linking.constructor();\n\nnewLinking.makeUrl = makeUrl;\nnewLinking.parse = parse;\nnewLinking.parseInitialURLAsync = parseInitialURLAsync;\n\nexport default newLinking as ExpoLinking;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}